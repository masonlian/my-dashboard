<!doctype html>
<html lang="zh Hang ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>追蹤所在場所</title>
</head>

    <body>

        <h1> 裝置位置追蹤中</h1>
        <h3>您正位於 <br>
            <span id = "location"></span></h3>
        <div>
            <p>距離場所登記還剩: <span id = "timer"></span>秒</p>
            <span id ="locationList"></span>
        </div>

    <script>
    //這段原本的語法當中少了非同步的概念，意思是當腳本呼叫API數據並不會理可以以物件的姿態馬上成為腳本的權域變數，
    // 根據不同API的需要使用譬如像callback函數之類的方法去把需要的物件招回。

    // 如果確認裝置是否離開特定區域，重心應該要放在“誤差”上而非地點本身，也就是說一開始就可以將所需要的誤差物件給定義出來。

    //今天debug 弄老半弄了一堆測試連後端都多配置了一些依靠，做結果只是網頁的快取沒有釋放掉，下次遇到這種不知道問題出在哪的狀況，
    //最重要的是細心的觀察遭遇到的所有過程，並且細心的一一推敲因果，往前的路上必定要去適應新環境。


    //一個場所一天設定一次




    //明天要成功讓經緯度送到後端，回傳placeDetail，在時效到達後前端呈現地點選項，點選後登記地點資訊進入SQL。這一連串的動作。

      const x = document.getElementById("location");
      const x1= document.getElementById("locationList")
      const x2 = document.getElementById("timer")




      const DWELL_MS = 10000;
      const CHECK_EVERY_MS = 1000;
      const LAT_DELTA = 0.00005;
      const LNG_DELTA = 0.00005;


      let anchorPos =  null;
      let lastPos = null ;
      let stillInThere = true;
      let startedAt = Date.now();
      let posName = null ;
      let posDetail= null;
      let remaining = DWELL_MS


      if ( !('geolocation' in navigator )) {
        x.textContent = "此瀏覽器不支援地理位置。"
      }

      else {



         const watchId  =  navigator.geolocation.watchPosition(  (pos)=> {
             console.log("watchId為:", watchId);


             lastPos = pos;
             if (!anchorPos) anchorPos = pos;

             const {latitude, longitude} = pos.coords;
             x.innerHTML =`緯度: ${latitude} <br>經度: ${longitude}`;


             const dLAT = Math.abs(latitude - anchorPos.coords.latitude);
             const dLNG = Math.abs(longitude - anchorPos.coords.longitude);

             if (dLAT > LAT_DELTA || dLNG > LNG_DELTA) {

                 stillInThere = false //邏輯上真實世界不符合情境
             }
             },

             (err) => {
                 x.textContent = `定位失敗: ${err.message}, (code ${err.code}) `;
                 console.log('定位失敗', err);
             },
                 {enableHighAccuracy: true, timeout: 100000, maximumAge: 0}
         )

          // JS的一大特點是可以將函數定濃縮一個常數ID去確認執行的先後順序。
          // 設計每天登載一次，24小時後重新紀錄，後端還要加上累計次數，理想情況應該是每一次記場所位置都新增一筆條目到
          // 後端的資料庫才是，那麼問題是，如果用setInterval去設定時追蹤的功能網頁就勢必就得一直開著，
          // 在理想的情況下我希望瀏覽器會替我記憶這個函數的“狀態”，這個狀態告訴我什麼時候使用過、使用帶來的結果是什麼諸如此類被記憶下的
          // “有用的資訊"，讓我能夠根據這個“狀態”近一步做操作，現在我能夠直覺想到的是cookie的技術（錯誤，應該使用localstorage，cookie是專門用於登入狀態與偏好設定，記憶的目的主要用於與後端做互動。調閱伺服器資料。）
          // 。也就是說如果我要記憶這個函數的使用時間再加以操作，中間是必有一連串與瀏覽器互動的過程是我要去設計的。
          //所以我要寫一段 localstorage

          //位置要持續做監控，然而30分鐘（時間區段到期後要重新計時開始新的一run），
          //在功能上計時跟監聽位置不能停止，把送出資料的條件限定在送出資聊的scope。
         // 取得地裡位置名稱

          async function getLocationDetail(longitude,latitude){

             const url = `/locationDetail?longitude=${longitude}&latitude=${latitude}`

              //這邊設計可以跳出選項的頁面

              try {
                  const response = await fetch(url);
                  const data = await response.json();
                  console.log("回傳資料:",data);

                  if (data) {
                      return data;
                  } else console.log('找不到地理名稱！')
                  return "未知地理名稱"
              }catch (err){  console.log('資料取得失敗')
             return "錯誤"
             }

          }



          async  function  sendData (url,payload) {


              try {

                  console.log("準備送出的資料:", payload);
                  const res = await fetch(url, {
                          method: "POST",
                          headers: {"Content-Type": "application/json"},
                          body: JSON.stringify(payload)
                      }
                  )
                  const ct = res.headers.get("Content-Type") || '';
                  let result = null;
                  if (res.ok && ct.includes("application/json")) {
                      result = await res.json();// 這邊要記載成功時間

                      const now = new Date;
                      localStorage.setItem("地點登錄時間", now.toISOString());
                      console.log("地點登錄時間為:", localStorage.getItem("地點登錄時間"));

                  } else if (res.status === 204) {
                      result = {status: "no_content"};
                  } else if (!res.ok) {
                      throw new Error("HTTP" + res.status);
                  }

                  console.log('停留時間已超過30分鐘，已登記！', result);
                  localStorage.setItem("result",JSON.stringify(result))


              } catch (err) {
                  console.log('送出失敗', err);
              }
          }




          setInterval( async() => {

              const now = Date.now();
              console.log("地理位置為:", lastPos.coords.longitude);
              console.log("startedAt:",startedAt);
              console.log("現在時間:",now );

              remaining = Math.ceil((DWELL_MS - (now - startedAt))/1000);
              x2.innerHTML=remaining


              if (now - startedAt > DWELL_MS) {



                  // let d1 = new Date();
                  // const today = d1.getDate();
                  // let d2 = new Date(localStorage.getItem("地點登錄時間"));
                  // const enrollDate = d2.getDate()
                  //
                  //  let m1 = new Date();
                  //  const thisMinute = m1.getMinutes();
                  //  console.log("當下分鐘數!",thisMinute)
                  //  let m2 = new Date(localStorage.getItem("地點登錄時間"));
                  //  const enrollMinute = m2.getMinutes();
                  //  console.log("登錄時分鐘數！",enrollMinute)  && thisMinute>enrollMinute
                  if (stillInThere && lastPos) {

                      posDetail = await getLocationDetail(lastPos.coords.longitude, lastPos.coords.latitude);
                      let results = posDetail.placeResponse.results;
                      console.log("資料回傳為:", results);


                      if (results) {
                          const posCandidate = [];
                          for (let i = 0; i < results.length; i++) {
                              posCandidate.push(results[i].name);
                          }

                          console.log("地名陣列為", posCandidate);

                      }

                      //到這邊彈出選項。
                      loadOption();

                      function loadOption(){

                          x1.innerHTML = `<dialog id="list">
                                          <h3> 附近場所名稱：</h3>
                                         <div id="place"></div>
                                         <button id = "closeDialog"> 關閉</button>
                                        </dialog>`;

                      }

                      const dialog = document.getElementById("list");
                      const closeDialog = document.getElementById("closeDialog");




                      function showList() {

                          document.getElementById('list').showModal();
                          closeDialog.addEventListener("click",() => dialog.close());

                      }

                      const placeList = document.getElementById("place");
                      //這是一個物件節點

                      showPos(results);

                      //DOM的概念不熟
                      function showPos (results) {

                          for (let i = 0; i < results.length; i++) {

                              const chooseBtn = document.createElement("button")
                              chooseBtn.textContent = results[i].name;
                              chooseBtn.addEventListener("click", () => checkPos(i));
                              placeList.appendChild(chooseBtn);

                              //把元素當成
                              placeList.appendChild(document.createElement("br"));

                          }

                          const btn = document.createElement("button")
                          btn.textContent = "請挑選你所在地點！";
                          btn.addEventListener("click", showList);
                          x1.appendChild(btn);


                      }




                      //先把邏輯敲對再去確認語法問題。
                      function checkPos(i) {

                          const locationJournal = {
                              latitude: posDetail.latitude,
                              longitude: posDetail.longitude,
                              acquiringTime: new Date().toISOString(),
                              publicName: posDetail.placeResponse.results[i].name,
                              address: posDetail.placeResponse.results[i].vicinity,
                              poi: posDetail.placeResponse.results[i].types.toString(),
                              placeId: posDetail.placeResponse.results[i].place_id
                          };


                          console.log("資料已登載",locationJournal)
                          sendData("/location",locationJournal)
                          dialog.close();
                          window.location.assign("enroll_success.html")


                      }

                  }

                  else {
                      console.log('中途離開，不登記!')
                  }

                  startedAt = Date.now();
              }


              console.log('尚未到達30分鐘');
              }
              ,
              CHECK_EVERY_MS)
      }






    </script>
</body>
</html>

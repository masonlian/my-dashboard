<!doctype html>
<html lang="zh Hang ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 生活重要場所登記頁面</title>  
</head>

    <body>


        <h1> 重要場所登記 </h1>
        <p>＃這邊應該要是一個table可以輸入重要場所的經緯度</p>

        <br>
        <div id="location"></div>



    <script>
    //這段原本的語法當中少了非同步的概念，意思是當腳本呼叫API數據並不會理可以以物件的姿態馬上成為腳本的權域變數，
    // 根據不同API的需要使用譬如像callback函數之類的方法去把需要的物件招回。

    // 如果確認裝置是否離開特定區域，重心應該要放在“誤差”上而非地點本身，也就是說一開始就可以將所需要的誤差物件給定義出來。

    //今天debug 弄老半弄了一堆測試連後端都多配置了一些依靠，做結果只是網頁的快取沒有釋放掉，下次遇到這種不知道問題出在哪的狀況，
    //最重要的是細心的觀察遭遇到的所有過程，並且細心的一一推敲因果，往前的路上必定要去適應新環境。


    //一個場所一天設定一次

      const x = document.getElementById("location");


      const DWELL_MS = 10000;
      const CHECK_EVERY_MS = 5000;
      const LAT_DELTA = 0.00005;
      const LNG_DELTA = 0.00005;


      let anchorPos =  null;
      let lastPos = null ;
      let stillInThere = true;
      let startedAt = Date.now();
      let posName = null ;
      let payload = null

      if ( !('geolocation' in navigator )) {
        x.textContent = "此瀏覽器不支援地理位置。"
      }

      else {

         const watchId  =  navigator.geolocation.watchPosition(  (pos)=> {
             console.log("watchId為:", watchId);


             lastPos = pos;
             if (!anchorPos) anchorPos = pos;

             const {latitude, longitude} = pos.coords;
             x.innerHTML =`緯度: ${latitude} <br>經度: ${longitude}`;



             const dLAT = Math.abs(latitude - anchorPos.coords.latitude);
             const dLNG = Math.abs(longitude - anchorPos.coords.longitude);

             if (dLAT > LAT_DELTA || dLNG > LNG_DELTA) {

                 stillInThere = false //邏輯上真實世界不符合情境
             }
             },

             (err) => {
                 x.textContent = `定位失敗: ${err.message}, (code ${err.code}) `;
                 console.log('定位失敗', err);
             },
                 {enableHighAccuracy: true, timeout: 100000, maximumAge: 0}
         )

          // JS的一大特點是可以將函數定濃縮一個常數ID去確認執行的先後順序。
          // 設計每天登載一次，24小時後重新紀錄，後端還要加上累計次數，理想情況應該是每一次記場所位置都新增一筆條目到
          // 後端的資料庫才是，那麼問題是，如果用setInterval去設定時追蹤的功能網頁就勢必就得一直開著，
          // 在理想的情況下我希望瀏覽器會替我記憶這個函數的“狀態”，這個狀態告訴我什麼時候使用過、使用帶來的結果是什麼諸如此類被記憶下的
          // “有用的資訊"，讓我能夠根據這個“狀態”近一步做操作，現在我能夠直覺想到的是cookie的技術（錯誤，應該使用localstorage，cookie是專門用於登入狀態與偏好設定，記憶的目的主要用於與後端做互動。調閱伺服器資料。）
          // 。也就是說如果我要記憶這個函數的使用時間再加以操作，中間是必有一連串與瀏覽器互動的過程是我要去設計的。
          //所以我要寫一段 localstorage

          //位置要持續做監控，然而30分鐘（時間區段到期後要重新計時開始新的一run），
          //在功能上計時跟監聽位置不能停止，把送出資料的條件限定在送出資聊的scope。

         // 取得地裡位置名稱

          async function getLocationName (longitude,latitude){

             const access_token = "pk.eyJ1IjoibWFzb24tbGlhbiIsImEiOiJjbWZ1cHRncG8xOHQ1Mm9wd2t2d2Fmb3RiIn0.iw9_sT2dqPSjlBzcwZYI0g" ;
             const url = `https://api.mapbox.com/search/geocode/v6/reverse?longitude=${longitude}&latitude=${latitude}&access_token=${access_token}`

              try {
                  const response = await fetch(url);
                  const data = await response.json();
                  console.log("回傳資料:",data);

                  if (data.features && data.features.length > 0) {
                      const placeName = data.features[0].properties.name;
                      console.log('取得地點為:', placeName);
                      return placeName;
                  } else console.log('找不到地理名稱！')
                  return "未知地理名稱"
              }catch (err){  console.log('資料取得失敗')
             return "錯誤"
             }

          }



          setInterval( async() => {
              const now = Date.now();

              if (now - startedAt > DWELL_MS) {

                 // let d1 = new Date();
                 // const today = d1.getDate();
                 // let d2 = new Date(localStorage.getItem("地點登錄時間"));
                 // const enrollDate = d2.getDate()
                 //
                 //  let m1 = new Date();
                 //  const thisMinute = m1.getMinutes();
                 //  console.log("當下分鐘數!",thisMinute)
                 //  let m2 = new Date(localStorage.getItem("地點登錄時間"));
                 //  const enrollMinute = m2.getMinutes();
                 //  console.log("登錄時分鐘數！",enrollMinute)  && thisMinute>enrollMinute

                  if (stillInThere &&lastPos) {
                      console.log("取得地點為:",posName);

                      posName = await getLocationName(lastPos.coords.longitude,lastPos.coords.latitude);

                      payload = {
                          locationName: posName,
                          latitude:lastPos.coords.latitude,
                          longitude:lastPos.coords.longitude,
                          acquiringTime:Date.now()
                      }




                      try {

                          const res = await fetch("/location", {
                                  method: "POST",
                                  headers: { "Content-Type" : "application/json" },
                                  body: JSON.stringify(payload)
                              }
                          )
                          const ct = res.headers.get("Content-Type") || '';
                          let result = null;
                          if (res.ok && ct.includes("application/json")) {
                              result = await res.json();// 這邊要記載成功時間

                              const now = new Date;
                              localStorage.setItem("地點登錄時間", now.toISOString());
                              console.log("地點登錄時間為:", localStorage.getItem("地點登錄時間"));

                          } else if (res.status === 204) {
                              result = {status: "no_content"};
                          } else if (!res.ok) {
                              throw new Error("HTTP" + res.status);
                          }

                          console.log('停留時間已超過30分鐘，已登記！', result);
                      } catch (err) {
                          console.log('送出失敗', err);
                      }
                  }

          else {console.log('中途離開，不登記!')};
              startedAt = Date.now();
          } console.log('尚未到達30分鐘')
              } ,CHECK_EVERY_MS)
      }



    </script>
</body>
</html>



設計程式的過程應該要考慮到使每個環節都可以被追蹤